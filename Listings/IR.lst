C51 COMPILER V9.59.0.0   IR                                                                10/15/2018 22:09:23 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE IR
OBJECT MODULE PLACED IN .\Objects\IR.obj
COMPILER INVOKED BY: E:\Keil\Keil_C51\C51\BIN\C51.EXE user\IR.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\user\Inc) DEBUG OBJECT
                    -EXTEND PRINT(.\Listings\IR.lst) OBJECT(.\Objects\IR.obj)

line level    source

   1          ///Á∫¢Â§ñÊé•Êî∂
   2          #include "IR.h"
   3          #include "PCA.h"
   4          #include "display.h"
   5          
   6          #define D_IR_SYNC_MAX       (30000)//(44117)//(15000/D_IR_sample) //SYNC max time
   7          #define D_IR_SYNC_MIN       (19400)//(28529)//(9700 /D_IR_sample) //SYNC min time
   8          #define D_IR_SYNC_DIVIDE    (24750)//(36397)//(12375/D_IR_sample) //decide data 0 or 1
   9          #define D_IR_DATA_MAX       (6000)//(8824)//(3000 /D_IR_sample) //data max time
  10          #define D_IR_DATA_MIN       (1200)//(1764)//(600  /D_IR_sample) //data min time
  11          #define D_IR_DATA_DIVIDE    (3374)//(4961)//(1687 /D_IR_sample) //decide data 0 or 1
  12          #define D_IR_BIT_NUMBER     32                  //bit number
  13          
  14          u32 xdata count0;                       //ËÆ∞ÂΩï‰∏ä‰∏ÄÊ¨°ÁöÑÊçïËé∑ÂÄº
  15          u32 xdata count1;                       //ËÆ∞ÂΩïÊú¨Ê¨°ÁöÑÊçïËé∑ÂÄº
  16          u32 xdata length;                       //Â≠òÂÇ®‰ø°Âè∑ÁöÑÊó∂Èó¥ÈïøÂ∫¶(count1 - count0)
  17          u32 xdata PulseL;                       //Â≠òÂÇ®‰ø°Âè∑ÁöÑ‰ΩéÁîµÂπ≥Êó∂Èó¥
  18          bit IR_flag; //Á∫¢Â§ñÊé•Êî∂Ê†áÂøó‰Ωç
  19          
  20          u8  xdata IR_BitCnt;          //ÁºñÁ†Å‰ΩçÊï∞
  21          u8  xdata IR_UserH;           //Áî®Êà∑Á†Å(Âú∞ÂùÄ)È´òÂ≠óËäÇ
  22          u8  xdata IR_UserL;           //Áî®Êà∑Á†Å(Âú∞ÂùÄ)‰ΩéÂ≠óËäÇ
  23          u8  xdata IR_data;            //Êï∞ÊçÆÂéüÁ†Å
  24          u8  xdata IR_DataShit;        //Êï∞ÊçÆÁßª‰Ωç
  25          u8  xdata IR_code;            //Á∫¢Â§ñÈîÆÁ†Å
  26          u16 xdata  UserCode;          //Áî®Êà∑Á†Å
  27          u32 xdata IR_RX_DATA;         //Á∫¢Â§ñÊé•Êî∂Âà∞Êï∞ÊçÆ
  28          
  29          bit P_IR_RX_temp;       //Last sample
  30          bit B_IR_Sync;          //Â∑≤Êî∂Âà∞ÂêåÊ≠•Ê†áÂøó
  31          bit B_IR_Press;         //ÂÆâÈîÆÂä®‰ΩúÂèëÁîü
  32          /********************** IRÊé•Êî∂‰ΩøËÉΩ  ************************/
  33          void IR_RX_Enable(u8 en)
  34          {
  35   1          CCF1 = 0; //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó‰Ωç
  36   1          CCAP1L = 0x00; //Ê∏ÖÈô§ËÆ°Êï∞ÂÄº
  37   1          CCAP1H = 0x00;
  38   1          //ÂàùÂßãÂåñÊâÄÊúâÂèòÈáè
  39   1          count0 = 0;
  40   1          count1 = 0;
  41   1          length = 0;
  42   1          PulseL = 0;
  43   1          IR_flag = 0;
  44   1          B_IR_Press = 0;
  45   1          if(en == 1)
  46   1          {
  47   2              //‰ΩøËÉΩIRÊé•Êî∂
  48   2              CCAPM1 = PCA_MODE_DW;                              //PCAÊ®°Âùó0‰∏∫16‰ΩçÊçïËé∑Ê®°Âºè(‰∏ãÈôçÊ≤øÊçïËé
             -∑)
  49   2          }
  50   1          else if(en == 0)
  51   1          {
  52   2              //ÂÖ≥Èó≠IRÊé•Êî∂
  53   2              CCAPM1 = 0;
C51 COMPILER V9.59.0.0   IR                                                                10/15/2018 22:09:23 PAGE 2   

  54   2          }
  55   1      }
  56          
  57          /**********************  IRÂú®ÊçïËé∑‰∏≠Êñ≠‰∏≠Ê£ÄÊµãÊ≥¢ÂΩ¢ ************************/
  58          void IR_RX_NEC(void)
  59          {
  60   1          if(CCAPM1 == PCA_MODE_DW)
  61   1          {
  62   2              //‰∏ãÈôçÊ≤øÊçïËé∑,‰∏ã‰∏ÄÊ¨°‰∏∫‰∏äÂçáÊ≤øÊçïËé∑
  63   2              CCAPM1 = PCA_MODE_UP;
  64   2              count0 = count1;            //Â§á‰ªΩ‰∏ä‰∏ÄÊ¨°ÁöÑÊçïËé∑ÂÄº
  65   2              ((u8 *)&count1)[3] = CCAP1L;  //‰øùÂ≠ò‰∏ãÈôçÊ≤øÊçïËé∑ÂÄº
  66   2              ((u8 *)&count1)[2] = CCAP1H;
  67   2              ((u8 *)&count1)[1] = PCA_CF;
  68   2              ((u8 *)&count1)[0] = 0;
  69   2              length = count1 - count0;   //Ê£ÄÊµãÊ≥¢ÂΩ¢ÁöÑÂë®Êúü
  70   2              ((u8 *)&length)[0] = 0;
  71   2              IR_flag = 1;//Êé•Êî∂Âà∞Êï∞ÊçÆ
  72   2          }
  73   1          else
  74   1          {
  75   2              //‰∏äÂçáÊ≤øÊçïËé∑,‰∏ã‰∏ÄÊ¨°ÊçïËé∑‰∏∫‰∏ãÈôçÊ≤øÊçïËé∑
  76   2              CCAPM1 = PCA_MODE_DW;
  77   2              ((u8 *)&PulseL)[3] = CCAP1L;  //‰øùÂ≠ò‰∏äÂçáÊ≤øÊó∂ËÆ°Êï∞ÂÄº
  78   2              ((u8 *)&PulseL)[2] = CCAP1H;
  79   2              ((u8 *)&PulseL)[1] = PCA_CF;
  80   2              ((u8 *)&PulseL)[0] = 0;
  81   2              PulseL = PulseL - count1;   //‰∏äÂçáÊ≤øÊçïËé∑ËÆ°Êï∞ÂÄº - ‰∏ãÈôçÊ≤øÊçïËé∑ÂÄº = ‰ΩéÁîµÂπ≥Êó∂Èó¥
  82   2              ((u8 *)&PulseL)[0] = 0;
  83   2          }
  84   1      
  85   1      }
  86          
  87          
  88          /**********************  Â§ÑÁêÜÊé•Êî∂Âà∞Êï∞ÊçÆ  ************************/
  89          void IRScan(void)
  90          {
  91   1          if(IR_flag == 1)
  92   1          {
  93   2              IR_flag = 0;
  94   2              if(length > D_IR_SYNC_MAX)
  95   2              {
  96   3                  B_IR_Sync = 0;  //large the Maxim SYNC time, then error
  97   3              }
  98   2              else if(length >= D_IR_SYNC_MIN)                    //SYNC
  99   2              {
 100   3                  if(length >= D_IR_SYNC_DIVIDE)
 101   3                  {
 102   4                      B_IR_Sync = 1;                  //has received SYNC
 103   4                      IR_BitCnt = D_IR_BIT_NUMBER;    //Load bit number
 104   4                  }
 105   3              }
 106   2              else if(B_IR_Sync)                      //has received SYNC
 107   2              {
 108   3                  if(length > D_IR_DATA_MAX)
 109   3                  {
 110   4                      B_IR_Sync=0;    //data samlpe time too large
 111   4                  }
 112   3                  else
 113   3                  {
 114   4                      IR_DataShit >>= 1;                  //data shift right 1 bit
 115   4                      if(length >= D_IR_DATA_DIVIDE)  IR_DataShit |= 0x80;    //devide data 0 or 1
C51 COMPILER V9.59.0.0   IR                                                                10/15/2018 22:09:23 PAGE 3   

 116   4                      if(--IR_BitCnt == 0)                //bit number is over?
 117   4                      {
 118   5                          B_IR_Sync = 0;                  //Clear SYNC
 119   5                          if(~IR_DataShit == IR_data)     //Âà§Êñ≠Êï∞ÊçÆÊ≠£ÂèçÁ†Å
 120   5                          {
 121   6                              IR_RX_DATA = ((u32)IR_UserH << 24) + ((u32)IR_UserL << 16) + (IR_data << 8) + IR_D
             -ataShit;
 122   6      //                        UserCode = ((u16)IR_UserH << 8) + IR_UserL;
 123   6      //                        IR_code      = IR_data;
 124   6                              B_IR_Press   = 1;           //Êï∞ÊçÆÊúâÊïà
 125   6                          }
 126   5                      }
 127   4                      else if((IR_BitCnt & 7)== 0)        //one byte receive
 128   4                      {
 129   5                          IR_UserL = IR_UserH;            //Save the User code high byte
 130   5                          IR_UserH = IR_data;             //Save the User code low byte
 131   5                          IR_data  = IR_DataShit;         //Save the IR data byte
 132   5                      }
 133   4                  }
 134   3              }
 135   2          }
 136   1          
 137   1      //     if(B_IR_Press == 1)
 138   1      //     {
 139   1      //         B_IR_Press = 0;
 140   1      // //        UartSend(((u8 *)&UserCode)[0]);
 141   1      // //        UartSend(((u8 *)&UserCode)[1]);
 142   1      // //        
 143   1      // //        UartSend(((u8 *)&IR_RX_DATA)[0]);
 144   1      // //        UartSend(((u8 *)&IR_RX_DATA)[1]);
 145   1      // //        UartSend(((u8 *)&IR_RX_DATA)[2]);
 146   1      // //        UartSend(((u8 *)&IR_RX_DATA)[3]);
 147   1      //     // }
 148   1      }
 149          
 150          
 151          
 152          
 153          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    605    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     28    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
